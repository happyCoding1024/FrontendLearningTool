<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>äºŒå‰æ ‘</title>
</head>
<body>
  <script>
    /**
     * æ³¨æ„ï¼š
     * 1ï¼‰åœ¨ç»™æ ‘æ’å…¥èŠ‚ç‚¹æ—¶å‡è®¾æ ‘æ˜¯äºŒå‰æœç´¢æ ‘ï¼Œå³å·¦èŠ‚ç‚¹å°äºçˆ¶èŠ‚ç‚¹ï¼Œå³èŠ‚ç‚¹å¤§äºçˆ¶èŠ‚ç‚¹ï¼Œåœ¨éå†ç®—æ³•ä¸­æ²¡æœ‰è¿™ä¸ªå‰ææ¡ä»¶
     * 2ï¼‰
     * 3ï¼‰
    */
    class Node {
      constructor (element) {
        this.key = element
        this.left = null
        this.right = null
      }
    }

    class BinarySearchTree {
      constructor () {
        this.root = null
      }
    }

    // å‘ BinarySearchTree ä¸­æ·»åŠ æ–¹æ³•
    Object.assign(BinarySearchTree.prototype, {
      inOrderTraverse,
      postOrderTraverse,
      preOrderTraverse,
      insert,
      preOrderTraverseNonRecursion,
      min,
      max,
      findNode,
      dfs,
      bfs,
    })

    // å‘æ ‘ä¸­æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹
    function insert (key) {
      const node = new Node(key)
      if (this.root === null) {
        this.root = node
      } else {
        insertNode(this.root, node)
      }

      function insertNode (node, newNode) {
        if (newNode.key < node.key) {
          if (node.left === null) {
            node.left = newNode
          } else {
            insertNode(node.left, newNode)
          }
        } else {
          if (node.right === null) {
            node.right = newNode
          } else {
            insertNode(node.right, newNode)
          }
        }
      }
    }

    // æ·±åº¦ä¼˜å…ˆéå†
    function dfs(callback) {
      return dfsNode(this.root);

      function dfsNode(node) {
        callback(node);
        
        if (node.left) dfsNode(node.left);
        if (node.right) dfsNode(node.right);
      }
    }

    // éé€’å½’ç‰ˆæ·±åº¦ä¼˜å…ˆéå†



    // å¹¿åº¦ä¼˜å…ˆéå†
    // é¦–å…ˆæ€è€ƒä½¿ç”¨å“ªä¸€ç§æ•°æ®ç»“æ„ï¼Œé€šè¿‡åˆ†æå¾—çŸ¥å…ˆè¿›å»æ˜¯å…ˆå‡ºå»çš„å› æ­¤å¾ˆæ˜æ˜¾æƒ³åˆ°ç”¨é˜Ÿåˆ—
    function bfs(callback) {
      const queue = [this.root];
      return bfsNode(this.root);

      function bfsNode(node) {
        while(queue.length) {
          const node = queue.shift();
          callback(node);
          if (node.left) queue.push(node.left);
          if (node.right) queue.push(node.right);
        }
      }
    }


    // éé€’å½’ç‰ˆå¹¿åº¦ä¼˜å…ˆéå†



    // é€’å½’ç‰ˆä¸­åºéå†
    function inOrderTraverse (callback) {
      inOrderTraverseNode(this.root, callback)
      function inOrderTraverseNode (node, callback) {
        if (node !== null) {
          inOrderTraverseNode(node.left, callback)
          callback(node.key)
          inOrderTraverseNode(node.right)
        }
      }
    }

    // é€’å½’ç‰ˆå…ˆåºéå†(å‰åºéå†)
    function preOrderTraverse (callback) {
      preOrderTraverseNode(this.root, callback)
      function preOrderTraverseNode (node, callback) {
        if (node !== null) {
          callback(node.key)
          preOrderTraverseNode(node.left, callback)
          preOrderTraverseNode(node.right, callback)
        }
      }
    }

    // é€’å½’ç‰ˆååºéå†
    function postOrderTraverse (callback) {
      postOrderTraverseNode(this.root, callback)
      function postOrderTraverseNode (node, callback) {
        if (node !== null) {
          postOrderTraverseNode(node.left, callback)
          postOrderTraverseNode(node.right, callback)
          callback(node.key)
        }
      }
    }

    // éé€’å½’ç‰ˆå…ˆåºéå†
    // æ¨¡æ‹Ÿå‡½æ•°é€’å½’è°ƒç”¨çš„è¿‡ç¨‹ï¼Œæ³¨æ„æ ¹å·¦å³ï¼Œè¿›æ ˆçš„æ—¶å€™æ˜¯å³å­æ ‘å…ˆè¿›å»ï¼Œå› ä¸ºå…ˆè¿›åå‡º
    function preOrderTraverseNonRecursion() {
      if (!this.root) return;
      const stack = [this.root];
      
      while(stack.length) {
        const n = stack.pop();
        console.log(n.key);
        if (n.right) stack.push(n.right);
        if (n.left) stack.push(n.left);
      }
    } 

    // éé€’å½’ç‰ˆä¸­åºéå†
    function inOrderTraverseNonRecursion() {

    }

    // å¯»æ‰¾æ ‘ä¸­çš„æœ€å°å€¼
    function min() {
      let node = this.root;
      
      if (!node) return null;

      while(node) {
        if (node.left) {
          node = node.left;
        } else {
          return node.key;
        }
      }
    }

    // å¯»æ‰¾æ ‘ä¸­çš„æœ€å¤§å€¼
    function max() {
      let node = this.root;

      if (!node) return null;

      while(node) {
        if (node.right) {
          node = node.right;
        } else {
          return node.key;
        }
      }
    }

    // æœç´¢ä¸€ä¸ªç‰¹å®šçš„å€¼ğŸ”
    function findNode(key) {
      return serchNode(this.root, key);

      function serchNode(node, key) {
        if (!node) return false;

        if (node.key < key) {
          return serchNode(node.right, key);
        } else if (node.key > key) {
          return serchNode(node.left, key);
        } else {
          return true;
        }
      }
    }

    // ç§»é™¤ä¸€ä¸ªèŠ‚ç‚¹
    function remove() {
      
      
      function removeNode() {

      }
    }

    // æµ‹è¯•ä»£ç 
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(10)
    tree.insert(12)
    tree.insert(13)
    tree.insert(9);
    console.log(tree)
    // tree.preOrderTraverseNonRecursion();
    // console.log(tree.min());
    // console.log(tree.max());
    // console.log('æŸ¥æ‰¾èŠ‚ç‚¹', tree.findNode(8));
    // tree.dfs((node) => console.log(node.key));
    tree.bfs((node) => console.log(node.key));
  </script>
</body>
</html>
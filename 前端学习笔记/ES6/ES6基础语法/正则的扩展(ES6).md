[TOC]

# 正则的扩展

## 1. RegExp 构造函数

`ES5` 中 `RegExp` 构造函数的两种用法：

1. 第一个参数是字符串，第二个参数是正则表达式的修饰符

```js
var regexp = new RegExp('xyz', 'g');
// 等价于
var regexp = /xyz/g;
```

2. 只有一个参数，参数是一个正则表达式，修饰符包含在这个正则表达式中，不允许出现第二个参数，否则会报错。

```js
var regexp = new RegExp(/xyz/g);
// 等价于
var regexp = /xyz/g;

// 下面这种情况会报错
var regexp = new (/xyz/g, 'i'); // ES5中当第一个参数是正则表达式时不允许出现第二个参数
```

`ES6` 解决了这个问题，而且第二个参数指定的修饰符会覆盖掉第一个参数中的修饰符。

```js
var regexp =new RegExp(/xyz/ig, 'i');
regexp.flags // 'i'
```

**注意：第二个参数中的修饰符是一个字符(字符串)，要用引号引起来。以修饰符 `i` 为例，若是不用引号引起来，那 `i` 不就表示一个变量了吗？**

## 2. 字符串的正则方法

字符串对象可以使用正则表达式的四个方法：

1. match()
2. replace()
3. split()
4. search()

`ES6` 使这4个方法在语言内部全部调用 `RegExp` 实例方法，从而做到所有与正则相关的方法都定义在 `RegExp` 对象上。

```js
String.prototype.match 调用 RegExp.prototype[symbol.match]
```

## 3. u 修饰符

`ES6` 对正则表达式新添加了 `u` 修饰符，用来处理码点大于 `\uFFFF` 的字符。**记住 `u` 修饰符的作用就是以前不能处理码点大于 `\uFFFF` 的字符，现在可以了。**

下面举例说明加上 `u` 修饰符后带来了哪些改变：

1. 测试匹配结果发生变化

```js
/^\uD842/u.test('\uD842\uDFB7'); // false
/^\uD842/.test('\uD842\uDFB7'); // true
```

 `'\uD842\uDFB7'` 是一个四字节 `UTF-16` 编码，代表字符 `'𠮷'`，若不加 `u` 修饰符，那么会将其当作两个字		 符，第一个字符为 `'\uD842'` 故会返回 `true` ,加上 `u` 修饰符之后就会将其识别为一个字符，不会和 `\uD842` 匹配，故会返回 `false` 。

2. 点字符

   点字符(`.`) 在正则表达式中的含义是除换行符之外的任意单个字符。

   **当码点大于 `\uFFFF` 时，点字符无法正确识别，当加上 `u` 修饰符时，点字符就可以识别了。** 

```js
var s = '𠮷';
/^.$/.test(s); // false
/^.$/u.test(s); // true
```

3. Unicode 字符表示

   在[字符串的扩展(ES6)1. 字符的Unicode表示法](https://blog.csdn.net/qq_43199318/article/details/102416174 )一节中我们知道，`ES6` 新增了了使用大括号来表示 `Unicode` 字符的表示法，`'\u{20BB7}'` 表示 `'𠮷'` 。

   **但是在正则表达式中，要想使用大括号表示 `Unicode` 字符，必须加上 `u` 修饰符，否则会被解读为量词。**

```js
/\u{61}/.test('a'); // false，不加u修饰符，会被认为连续匹配61个u字符
/\u{61}/u.test('a'); // true
```

4. 量词

   |        不使用 `u` 修饰符         |         使用 `u` 修饰符          |
   | :------------------------------: | :------------------------------: |
   | 只能识别码点小于 `\uFFFF` 的字符 | 可以识别码点大于 `\uFFFF` 的字符 |

5. `i` 修饰符

   有些 `Unicode` 字符的编码不同，但是字型是相近或相同的，比如， `\u004B` 和 `\u212A` 都是大写的 `'K'`。字符有规范和不规范一说，不使用 `u` 修饰符就不能识别非规范的 `Unicode` 字符。

```js
/[a-z]/i.test('\u212A'); // false
/[a-z]/iu.test('\u212A'); // true
```

​	如果不加 `u` 修饰符就不能识别出非规范的 `K` 字符，出现遗漏等情况。

## 4. y 修饰符

`y` 修饰符的作用与 `g` 修饰符的作用类似，都是全局匹配，但是 `g` 修饰符只要在剩余位置下存在匹配就行，而 `y` 修饰符必须要从剩余的第一个位置开始匹配，也就是暗含头部匹配的条件。

`y` 修饰符又叫“粘连”修饰符

```js
var s = "aaa_aa_a";
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s); // ["aaa"], lastIndex=3
r2.exec(s); // ["aaa"], lastIndex=3

r1.exec(s); // ["aa"]， 从"aaa_aa_a"中第4个位置"_"开始匹配，由于是g，故可以匹配到"aa".
r2.exec(s); // null, 从"aaa_aa_a"中第4个位置"_"开始匹配，由于是y暗含头部匹配，所以必须从开始的第一个  // 位置就要匹配上，但是开始匹配的第一个位置是"_",所以匹配不上。
```

## 5. sticky 属性

只读布尔值，表示是否设置了y修饰符

## 6. flags 属性

返回正则表达式的修饰符 `/abc/ig.flags // 'gi'`

## 7. s 修饰符：dotAll 模式

使 `'.'` 修饰符可以匹配任意一个字符

## 8. 后行断言

|     字符     | 含义                                                         |
| :----------: | :----------------------------------------------------------- |
| (?<=p)(提案) | 后行断言，要求前面的字符要与p匹配，并且匹配的结果中不包含p，如 `var result = /(?<=\$)\d+/.exec('$100*80'); // result=['100']` |
|    (?<!p)    | 后行否定断言，要求前面的字符不能与p匹配，并且匹配结果中不包含p，如 `var result= /(?!\$)\d+/.exec('$100*80');  // result=['80']` |

## 9. 具名组匹配

|      字符       | 含义                                                         |
| :-------------: | :----------------------------------------------------------- |
| (?<name>)(提案) | 具名组                                                                                                                                               `格式`：“问号+尖括号+组名”                                                                                                                    `作用`：为每一个组匹配指定一个名字 ，可以通过exec方法返回结果的groups属性上引用该组名                                                                                                                                                        `示例1`： `let result = /(?<year>\d{4})-(?<month>\d{2})/.exec('2019-10');` // result=['2019-10','2019',10]  result.groups={year:'2019', month:'10'}                                                   `注意`：如果要在正则表达式内部引用某个“具名组匹配”，可以使用 `\k<组名>` 的写法，同时数组引用也依然有效                                                                                                                               `示例2`：`let result = /^(?<word>[a-z]+)!\k(word)!\1$/.test('abc!abc!abc') // true`           `let result = /^(?<word>[a-z]+)!\k(word)!\1$/.test('abc!abc!ab') // false` |

